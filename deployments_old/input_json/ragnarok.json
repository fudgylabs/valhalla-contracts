{"language":"Solidity","sources":{"src/distribution/Ragnarok.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IBasisAsset.sol\";\n\nimport \"../interfaces/shadow/IGauge.sol\";\nimport \"../interfaces/shadow/IVoter.sol\";\n\ncontract Ragnarok is ReentrancyGuard {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  // governance\n  address public operator;\n\n  // Info of each user.\n  struct UserInfo {\n    uint256 amount; // How many LP tokens the user has provided.\n    uint256 rewardDebt; // Reward debt. See explanation below.\n  }\n\n  struct GaugeInfo {\n    bool isGauge; // If this is a gauge\n    IGauge gauge; // The gauge\n    address[] rewardTokens; // tokens that are used in the gauge\n  }\n\n  // Info of each pool.\n  struct PoolInfo {\n    IERC20 token; // Address of LP token contract.\n    uint256 depFee; // deposit fee that is applied to created pool.\n    uint256 allocPoint; // How many allocation points assigned to this pool. VALs to distribute per block.\n    uint256 lastRewardTime; // Last time that VALs distribution occurs.\n    uint256 accValhallaPerShare; // Accumulated VALs per share, times 1e18. See below.\n    bool isStarted; // if lastRewardTime has passed\n    GaugeInfo gaugeInfo; // Gauge info (does this pool have a gauge and where is it)\n    uint256 poolValhallaPerSec; // rewards per second for pool (acts as allocPoint)\n  }\n\n  IERC20 public valhalla;\n  IVoter public voter;\n  address public xSHADOW = 0x5050bc082FF4A74Fb6B0B04385dEfdDB114b2424;\n  address public devFund;\n\n  // Info of each pool.\n  PoolInfo[] public poolInfo;\n\n  // Info of each user that stakes LP tokens.\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n  // Total allocation points. Must be the sum of all allocation points in all pools.\n  uint256 public totalAllocPoint = 0;\n\n  // The time when VAL mining starts.\n  uint256 public poolStartTime;\n\n  // The time when VAL mining ends.\n  uint256 public poolEndTime;\n  uint256 public valhallaPerSecond = 0 ether;\n  uint256 public runningTime = 7 days;\n\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n  event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n  event RewardPaid(address indexed user, uint256 amount);\n\n  constructor(address _valhalla, address _devFund, uint256 _poolStartTime, address _voter) {\n    require(block.timestamp < _poolStartTime, \"pool cant be started in the past\");\n    if (_valhalla != address(0)) valhalla = IERC20(_valhalla);\n    if (_devFund != address(0)) devFund = _devFund;\n\n    poolStartTime = _poolStartTime;\n    poolEndTime = _poolStartTime + runningTime;\n    operator = msg.sender;\n    voter = IVoter(_voter);\n    devFund = _devFund;\n\n    // create all the pools (daily rewards divided by 86400 seconds)\n    // add(0.237268519 ether, 0, IERC20(address(0)), false, 0); // VAL-OS LP 143.5k (20500/86400)\n    add(0.115740741 ether, 150, IERC20(0xb1e25689D55734FD3ffFc939c4C3Eb52DFf8A794), false, 0); // OS 70k (10000/86400)\n    add(0.138888889 ether, 150, IERC20(0xd3DCe716f3eF535C5Ff8d041c1A41C3bd89b97aE), false, 0); // SCUSD 84k (12000/86400)\n    add(0.0891203704 ether, 150, IERC20(0x3bcE5CB273F0F148010BbEa2470e7b5df84C7812), false, 0); // SCETH 53.9k (7700/86400)\n    add(0.0891203704 ether, 150, IERC20(0xBb30e76d9Bb2CC9631F7fC5Eb8e87B5Aff32bFbd), false, 0); // SCBTC 53.9k (7700/86400)\n    add(0.0405092593 ether, 150, IERC20(0xE5DA20F15420aD15DE0fa650600aFc998bbE3955), false, 0); // STS 24.5k (3500/86400)\n    add(0.0405092593 ether, 150, IERC20(0x3333b97138D4b086720b5aE8A7844b1345a33333), false, 0); // SHADOW 24.5k (3500/86400)\n    add(0.0324074074 ether, 150, IERC20(0x3333111A391cC08fa51353E9195526A70b333333), false, 0); // X33 19.6k (2800/86400)\n    add(0.0324074074 ether, 150, IERC20(0x7A0C53F7eb34C5BC8B01691723669adA9D6CB384), false, 0); // BOO 19.6k (2800/86400)\n    add(0.0324074074 ether, 150, IERC20(0xddF26B42C1d903De8962d3F79a74a501420d5F19), false, 0); // EQUAL 19.6k (2800/86400)\n    add(0.0289351852 ether, 150, IERC20(0xf26Ff70573ddc8a90Bd7865AF8d7d70B8Ff019bC), false, 0); // EGGS 17.5k (2500/86400)\n    add(0.0173611111 ether, 150, IERC20(0x79bbF4508B1391af3A0F4B30bb5FC4aa9ab0E07C), false, 0); // ANON 10.5k (1500/86400)\n    add(0.0133101852 ether, 150, IERC20(0xe920d1DA9A4D59126dC35996Ea242d60EFca1304), false, 0); // DERP 8.05k (1150/86400)\n    add(0.0115740741 ether, 150, IERC20(0x9fDbC3f8Abc05Fa8f3Ad3C17D2F806c1230c4564), false, 0); // GOGLZ 7k (1000/86400)\n    add(0.0115740741 ether, 150, IERC20(0x6fB9897896Fe5D05025Eb43306675727887D0B7c), false, 0); // HEDGY 7k (1000/86400)\n    add(0.0150462963 ether, 150, IERC20(0x31E2eed04a62b232DA964A097D8C171584e3C3Bd), false, 0); // OIL 9.1k (1300/86400)\n    add(0.0115740741 ether, 150, IERC20(0xf4F9C50455C698834Bb645089DbAa89093b93838), false, 0); // TOONA 7k (1000/86400)\n    add(0.0115740741 ether, 150, IERC20(0xE51EE9868C1f0d6cd968A8B8C8376Dc2991BFE44), false, 0); // BRUSH 7k (1000/86400)\n    add(0.00810185185 ether, 150, IERC20(0x7A08Bf5304094CA4C7b4132Ef62b5EDc4a3478B7), false, 0); // ECO 4.9k (700/86400)\n  }\n\n  modifier onlyOperator() {\n    require(operator == msg.sender, \"Ragnarok: caller is not the operator\");\n    _;\n  }\n\n  function poolLength() external view returns (uint256) {\n    return poolInfo.length;\n  }\n\n  function checkPoolDuplicate(IERC20 _token) internal view {\n    uint256 length = poolInfo.length;\n    for (uint256 pid = 0; pid < length; ++pid) {\n      require(poolInfo[pid].token != _token, \"Ragnarok: existing pool?\");\n    }\n  }\n\n  // bulk add pools\n  function addBulk(\n    uint256[] calldata _allocPoints,\n    uint256[] calldata _depFees,\n    IERC20[] calldata _tokens,\n    bool _withUpdate,\n    uint256 _lastRewardTime\n  ) external onlyOperator {\n    require(\n      _allocPoints.length == _depFees.length && _allocPoints.length == _tokens.length,\n      \"Ragnarok: invalid length\"\n    );\n    for (uint256 i = 0; i < _allocPoints.length; i++) {\n      add(_allocPoints[i], _depFees[i], _tokens[i], _withUpdate, _lastRewardTime);\n    }\n  }\n\n  // Add new lp to the pool. Can only be called by operator.\n  function add(\n    uint256 _allocPoint,\n    uint256 _depFee,\n    IERC20 _token,\n    bool _withUpdate,\n    uint256 _lastRewardTime\n  ) public onlyOperator {\n    checkPoolDuplicate(_token);\n    if (_withUpdate) {\n      massUpdatePools();\n    }\n    if (block.timestamp < poolStartTime) {\n      // chef is sleeping\n      if (_lastRewardTime == 0) {\n        _lastRewardTime = poolStartTime;\n      } else {\n        if (_lastRewardTime < poolStartTime) {\n          _lastRewardTime = poolStartTime;\n        }\n      }\n    } else {\n      // chef is cooking\n      if (_lastRewardTime == 0 || _lastRewardTime < block.timestamp) {\n        _lastRewardTime = block.timestamp;\n      }\n    }\n    bool _isStarted = (_lastRewardTime <= poolStartTime) || (_lastRewardTime <= block.timestamp);\n    address[] memory rewardTokensGauge = new address[](1);\n    rewardTokensGauge[0] = xSHADOW;\n    poolInfo.push(\n      PoolInfo({\n        token: _token,\n        depFee: _depFee,\n        allocPoint: _allocPoint,\n        poolValhallaPerSec: _allocPoint,\n        lastRewardTime: _lastRewardTime,\n        accValhallaPerShare: 0,\n        isStarted: _isStarted,\n        gaugeInfo: GaugeInfo(false, IGauge(address(0)), rewardTokensGauge)\n      })\n    );\n\n    if (_isStarted) {\n      totalAllocPoint = totalAllocPoint.add(_allocPoint);\n      valhallaPerSecond = valhallaPerSecond.add(_allocPoint);\n    }\n  }\n\n  // Update the given pool's VAL allocation point. Can only be called by the operator.\n  function set(uint256 _pid, uint256 _allocPoint, uint256 _depFee) public onlyOperator {\n    massUpdatePools();\n\n    PoolInfo storage pool = poolInfo[_pid];\n    require(_depFee < 200); // deposit fee cant be more than 2%;\n    pool.depFee = _depFee;\n\n    if (pool.isStarted) {\n      totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(_allocPoint);\n      valhallaPerSecond = valhallaPerSecond.sub(pool.poolValhallaPerSec).add(_allocPoint);\n    }\n    pool.allocPoint = _allocPoint;\n    pool.poolValhallaPerSec = _allocPoint;\n  }\n\n  function bulkSet(\n    uint256[] calldata _pids,\n    uint256[] calldata _allocPoints,\n    uint256[] calldata _depFees\n  ) external onlyOperator {\n    require(\n      _pids.length == _allocPoints.length && _pids.length == _depFees.length,\n      \"Ragnarok: invalid length\"\n    );\n    for (uint256 i = 0; i < _pids.length; i++) {\n      set(_pids[i], _allocPoints[i], _depFees[i]);\n    }\n  }\n\n  // Return accumulate rewards over the given _from to _to block.\n  function getGeneratedReward(uint256 _fromTime, uint256 _toTime) public view returns (uint256) {\n    if (_fromTime >= _toTime) return 0;\n    if (_toTime >= poolEndTime) {\n      if (_fromTime >= poolEndTime) return 0;\n      if (_fromTime <= poolStartTime) return poolEndTime.sub(poolStartTime).mul(valhallaPerSecond);\n      return poolEndTime.sub(_fromTime).mul(valhallaPerSecond);\n    } else {\n      if (_toTime <= poolStartTime) return 0;\n      if (_fromTime <= poolStartTime) return _toTime.sub(poolStartTime).mul(valhallaPerSecond);\n      return _toTime.sub(_fromTime).mul(valhallaPerSecond);\n    }\n  }\n\n  // View function to see pending VALs on frontend.\n  function pendingVAL(uint256 _pid, address _user) external view returns (uint256) {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_user];\n    uint256 accValhallaPerShare = pool.accValhallaPerShare;\n    uint256 tokenSupply = pool.token.balanceOf(address(this));\n    if (block.timestamp > pool.lastRewardTime && tokenSupply != 0) {\n      uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\n      uint256 _valhallaReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\n      accValhallaPerShare = accValhallaPerShare.add(_valhallaReward.mul(1e18).div(tokenSupply));\n    }\n    return user.amount.mul(accValhallaPerShare).div(1e18).sub(user.rewardDebt);\n  }\n\n  function massUpdatePools() public {\n    uint256 length = poolInfo.length;\n    for (uint256 pid = 0; pid < length; ++pid) {\n      updatePool(pid);\n      updatePoolWithGaugeDeposit(pid);\n    }\n  }\n\n  // massUpdatePoolsInRange\n  function massUpdatePoolsInRange(uint256 _fromPid, uint256 _toPid) public {\n    require(_fromPid <= _toPid, \"Ragnarok: invalid range\");\n    for (uint256 pid = _fromPid; pid <= _toPid; ++pid) {\n      updatePool(pid);\n      updatePoolWithGaugeDeposit(pid);\n    }\n  }\n\n  // Update reward variables of the given pool to be up-to-date.\n  function updatePool(uint256 _pid) private {\n    PoolInfo storage pool = poolInfo[_pid];\n    if (block.timestamp <= pool.lastRewardTime) {\n      return;\n    }\n    uint256 tokenSupply = pool.token.balanceOf(address(this));\n    if (tokenSupply == 0) {\n      pool.lastRewardTime = block.timestamp;\n      return;\n    }\n    if (!pool.isStarted) {\n      pool.isStarted = true;\n      totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\n      valhallaPerSecond = valhallaPerSecond.add(pool.poolValhallaPerSec);\n    }\n    if (totalAllocPoint > 0) {\n      uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\n      uint256 _valhallaReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\n      pool.accValhallaPerShare = pool.accValhallaPerShare.add(\n        _valhallaReward.mul(1e18).div(tokenSupply)\n      );\n    }\n    pool.lastRewardTime = block.timestamp;\n    claimLegacyRewards(_pid);\n  }\n\n  // Deposit LP tokens to earn rewards\n  function updatePoolWithGaugeDeposit(uint256 _pid) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    address gauge = address(pool.gaugeInfo.gauge);\n    uint256 balance = pool.token.balanceOf(address(this));\n    // Do nothing if this pool doesn't have a gauge\n    if (pool.gaugeInfo.isGauge) {\n      // Do nothing if the LP token in the MC is empty\n      if (balance > 0) {\n        // Approve to the gauge\n        if (pool.token.allowance(address(this), gauge) < balance) {\n          pool.token.approve(gauge, type(uint256).max);\n        }\n        // Deposit the LP in the gauge\n        pool.gaugeInfo.gauge.depositFor(address(this), balance);\n      }\n    }\n  }\n\n  // Claim rewards to treasury\n  function claimLegacyRewards(uint256 _pid) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    if (pool.gaugeInfo.isGauge) {\n      if (pool.gaugeInfo.rewardTokens.length > 0) {\n        uint256[] memory beforeBalances = new uint256[](pool.gaugeInfo.rewardTokens.length);\n\n        // Store balances before claim\n        for (uint256 i = 0; i < pool.gaugeInfo.rewardTokens.length; i++) {\n          beforeBalances[i] = IERC20(pool.gaugeInfo.rewardTokens[i]).balanceOf(address(this));\n        }\n\n        address[] memory gaugesToCheck = new address[](1);\n        gaugesToCheck[0] = address(pool.gaugeInfo.gauge);\n\n        address[][] memory gaugeRewardTokens = new address[][](1);\n        gaugeRewardTokens[0] = pool.gaugeInfo.rewardTokens;\n\n        voter.claimRewards(gaugesToCheck, gaugeRewardTokens);\n\n        for (uint256 i = 0; i < pool.gaugeInfo.rewardTokens.length; i++) {\n          IERC20 rewardToken = IERC20(pool.gaugeInfo.rewardTokens[i]);\n          uint256 afterBalance = rewardToken.balanceOf(address(this));\n          uint256 rewardAmount = afterBalance - beforeBalances[i];\n\n          if (rewardAmount > 0) {\n            rewardToken.safeTransfer(devFund, rewardAmount);\n          }\n        }\n      }\n    }\n  }\n\n  // Add a gauge to a pool\n  function enableGauge(uint256 _pid) public onlyOperator {\n    address gauge = voter.gaugeForPool(address(poolInfo[_pid].token));\n    if (gauge != address(0)) {\n      address[] memory rewardTokensGauge = new address[](1);\n      rewardTokensGauge[0] = xSHADOW;\n      poolInfo[_pid].gaugeInfo = GaugeInfo(true, IGauge(gauge), rewardTokensGauge);\n    }\n  }\n\n  function setGaugeRewardTokens(\n    uint256 _pid,\n    address[] calldata _rewardTokens\n  ) public onlyOperator {\n    PoolInfo storage pool = poolInfo[_pid];\n    require(pool.gaugeInfo.isGauge, \"Ragnarok: not a gauge pool\");\n    pool.gaugeInfo.rewardTokens = _rewardTokens;\n  }\n\n  function setDevFund(address _devFund) public onlyOperator {\n    devFund = _devFund;\n  }\n\n  // Withdraw LP from the gauge\n  function withdrawFromGauge(uint256 _pid, uint256 _amount) internal {\n    PoolInfo storage pool = poolInfo[_pid];\n    // Do nothing if this pool doesn't have a gauge\n    if (pool.gaugeInfo.isGauge) {\n      // Withdraw from the gauge\n      pool.gaugeInfo.gauge.withdraw(_amount);\n    }\n  }\n\n  // Deposit LP tokens.\n  function deposit(uint256 _pid, uint256 _amount) public nonReentrant {\n    address _sender = msg.sender;\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_sender];\n    updatePool(_pid);\n    if (user.amount > 0) {\n      uint256 _pending = user.amount.mul(pool.accValhallaPerShare).div(1e18).sub(user.rewardDebt);\n      if (_pending > 0) {\n        safeValhallaTransfer(_sender, _pending);\n        emit RewardPaid(_sender, _pending);\n      }\n    }\n    if (_amount > 0) {\n      pool.token.safeTransferFrom(_sender, address(this), _amount);\n      uint256 depositDebt = _amount.mul(pool.depFee).div(10000);\n      user.amount = user.amount.add(_amount.sub(depositDebt));\n      pool.token.safeTransfer(devFund, depositDebt);\n    }\n    updatePoolWithGaugeDeposit(_pid);\n    user.rewardDebt = user.amount.mul(pool.accValhallaPerShare).div(1e18);\n    emit Deposit(_sender, _pid, _amount);\n  }\n\n  // Withdraw LP tokens.\n  function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {\n    address _sender = msg.sender;\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_sender];\n    require(user.amount >= _amount, \"withdraw: not good\");\n    updatePool(_pid);\n    updatePoolWithGaugeDeposit(_pid);\n    uint256 _pending = user.amount.mul(pool.accValhallaPerShare).div(1e18).sub(user.rewardDebt);\n    if (_pending > 0) {\n      safeValhallaTransfer(_sender, _pending);\n      emit RewardPaid(_sender, _pending);\n    }\n    if (_amount > 0) {\n      user.amount = user.amount.sub(_amount);\n      withdrawFromGauge(_pid, _amount);\n      pool.token.safeTransfer(_sender, _amount);\n    }\n    user.rewardDebt = user.amount.mul(pool.accValhallaPerShare).div(1e18);\n    emit Withdraw(_sender, _pid, _amount);\n  }\n\n  // Withdraw without caring about rewards. EMERGENCY ONLY.\n  function emergencyWithdraw(uint256 _pid) public nonReentrant {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n    uint256 _amount = user.amount;\n    withdrawFromGauge(_pid, _amount);\n    user.amount = 0;\n    user.rewardDebt = 0;\n    pool.token.safeTransfer(msg.sender, _amount);\n    emit EmergencyWithdraw(msg.sender, _pid, _amount);\n  }\n\n  // Safe valhalla transfer function, just in case if rounding error causes pool to not have enough VALs.\n  function safeValhallaTransfer(address _to, uint256 _amount) internal {\n    uint256 _valhallaBal = valhalla.balanceOf(address(this));\n    if (_valhallaBal > 0) {\n      if (_amount > _valhallaBal) {\n        valhalla.safeTransfer(_to, _valhallaBal);\n      } else {\n        valhalla.safeTransfer(_to, _amount);\n      }\n    }\n  }\n\n  function setOperator(address _operator) external onlyOperator {\n    operator = _operator;\n  }\n\n  function governanceRecoverUnsupported(\n    IERC20 _token,\n    uint256 amount\n  ) external {\n    if (block.timestamp < poolEndTime + 7 days) {\n      // do not allow to drain tokens if less than 7 days after pool ends\n      uint256 length = poolInfo.length;\n      for (uint256 pid = 0; pid < length; ++pid) {\n        PoolInfo storage pool = poolInfo[pid];\n        require(_token != pool.token, \"token cannot be pool token\");\n      }\n    }\n\n    _token.safeTransfer(devFund, amount);\n  }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"src/interfaces/IBasisAsset.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasisAsset {\n  function mint(address recipient, uint256 amount) external returns (bool);\n\n  function burn(uint256 amount) external;\n\n  function burnFrom(address from, uint256 amount) external;\n\n  function isOperator() external returns (bool);\n\n  function operator() external view returns (address);\n\n  function transferOperator(address newOperator_) external;\n}\n"},"src/interfaces/shadow/IGauge.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.26;\ninterface IGauge {\n  error ZERO_AMOUNT();\n\n  error CANT_NOTIFY_STAKE();\n\n  error REWARD_TOO_HIGH();\n\n  error NOT_GREATER_THAN_REMAINING(uint256 amount, uint256 remaining);\n\n  error TOKEN_ERROR(address token);\n\n  error NOT_WHITELISTED();\n\n  error NOT_AUTHORIZED();\n\n  event Deposit(address indexed from, uint256 amount);\n\n  event Withdraw(address indexed from, uint256 amount);\n\n  event NotifyReward(address indexed from, address indexed reward, uint256 amount);\n\n  event ClaimRewards(address indexed from, address indexed reward, uint256 amount);\n\n  event RewardWhitelisted(address indexed reward, bool whitelisted);\n\n  /// @notice Get the amount of stakingToken deposited by an account\n  function balanceOf(address) external view returns (uint256);\n\n  /// @notice returns an array with all the addresses of the rewards\n  /// @return _rewards array of addresses for rewards\n  function rewardsList() external view returns (address[] memory _rewards);\n\n  /// @notice number of different rewards the gauge has facilitated that are 'active'\n  /// @return _length the number of individual rewards\n  function rewardsListLength() external view returns (uint256 _length);\n\n  /// @notice returns the last time the reward was modified or periodFinish if the reward has ended\n  /// @param token address of the token\n  /// @return ltra last time reward applicable\n  function lastTimeRewardApplicable(address token) external view returns (uint256 ltra);\n\n  /// @notice displays the data struct of rewards for a token\n  /// @param token the address of the token\n  /// @return data rewards struct\n  function rewardData(address token) external view returns (Reward memory data);\n\n  /// @notice calculates the amount of tokens earned for an address\n  /// @param token address of the token to check\n  /// @param account address to check\n  /// @return _reward amount of token claimable\n  function earned(address token, address account) external view returns (uint256 _reward);\n  /// @notice claims rewards (shadow + any external LP Incentives)\n  /// @param account the address to claim for\n  /// @param tokens an array of the tokens to claim\n  function getReward(address account, address[] calldata tokens) external;\n\n  /// @notice claims all rewards and instant exits xshadow into shadow\n  function getRewardAndExit(address account, address[] calldata tokens) external;\n\n  /// @notice calculates the token amounts earned per lp token\n  /// @param token address of the token to check\n  /// @return rpt reward per token\n  function rewardPerToken(address token) external view returns (uint256 rpt);\n\n  /// @notice deposit all LP tokens from msg.sender's wallet to the gauge\n  function depositAll() external;\n  /// @param recipient the address of who to deposit on behalf of\n  /// @param amount the amount of LP tokens to withdraw\n  function depositFor(address recipient, uint256 amount) external;\n\n  /// @notice deposit LP tokens to the gauge\n  /// @param amount the amount of LP tokens to withdraw\n  function deposit(uint256 amount) external;\n\n  /// @notice withdraws all fungible LP tokens from legacy gauges\n  function withdrawAll() external;\n\n  /// @notice withdraws fungible LP tokens from legacy gauges\n  /// @param amount the amount of LP tokens to withdraw\n  function withdraw(uint256 amount) external;\n\n  /// @notice calculates how many tokens are left to be distributed\n  /// @dev reduces per second\n  /// @param token the address of the token\n  function left(address token) external view returns (uint256);\n  /// @notice add a reward to the whitelist\n  /// @param _reward address of the reward\n  function whitelistReward(address _reward) external;\n\n  /// @notice remove rewards from the whitelist\n  /// @param _reward address of the reward\n  function removeRewardWhitelist(address _reward) external;\n\n  /**\n   * @notice amount must be greater than left() for the token, this is to prevent griefing attacks\n   * @notice notifying rewards is completely permissionless\n   * @notice if nobody registers for a newly added reward for the period it will remain in the contract indefinitely\n   */\n  function notifyRewardAmount(address token, uint256 amount) external;\n\n  struct Reward {\n    /// @dev tokens per second\n    uint256 rewardRate;\n    /// @dev 7 days after start\n    uint256 periodFinish;\n    uint256 lastUpdateTime;\n    uint256 rewardPerTokenStored;\n  }\n\n  /// @notice checks if a reward is whitelisted\n  /// @param reward the address of the reward\n  /// @return true if the reward is whitelisted, false otherwise\n  function isWhitelisted(address reward) external view returns (bool);\n}\n"},"src/interfaces/shadow/IVoter.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.26;\npragma abicoder v2;\n\ninterface IVoter {\n  error ACTIVE_GAUGE(address gauge);\n\n  error GAUGE_INACTIVE(address gauge);\n\n  error ALREADY_WHITELISTED(address token);\n\n  error NOT_AUTHORIZED(address caller);\n\n  error NOT_WHITELISTED();\n\n  error NOT_POOL();\n\n  error NOT_INIT();\n\n  error LENGTH_MISMATCH();\n\n  error NO_GAUGE();\n\n  error ALREADY_DISTRIBUTED(address gauge, uint256 period);\n\n  error ZERO_VOTE(address pool);\n\n  error RATIO_TOO_HIGH(uint256 _xRatio);\n\n  error VOTE_UNSUCCESSFUL();\n\n  event GaugeCreated(\n    address indexed gauge,\n    address creator,\n    address feeDistributor,\n    address indexed pool\n  );\n\n  event GaugeKilled(address indexed gauge);\n\n  event GaugeRevived(address indexed gauge);\n\n  event Voted(address indexed owner, uint256 weight, address indexed pool);\n\n  event Abstained(address indexed owner, uint256 weight);\n\n  event Deposit(address indexed lp, address indexed gauge, address indexed owner, uint256 amount);\n\n  event Withdraw(address indexed lp, address indexed gauge, address indexed owner, uint256 amount);\n\n  event NotifyReward(address indexed sender, address indexed reward, uint256 amount);\n\n  event DistributeReward(address indexed sender, address indexed gauge, uint256 amount);\n\n  event EmissionsRatio(address indexed caller, uint256 oldRatio, uint256 newRatio);\n\n  event NewGovernor(address indexed sender, address indexed governor);\n\n  event Whitelisted(address indexed whitelister, address indexed token);\n\n  event WhitelistRevoked(address indexed forbidder, address indexed token, bool status);\n\n  event MainTickSpacingChanged(\n    address indexed token0,\n    address indexed token1,\n    int24 indexed newMainTickSpacing\n  );\n\n  event Poke(address indexed user);\n\n  function initialize(\n    address _shadow,\n    address _legacyFactory,\n    address _gauges,\n    address _feeDistributorFactory,\n    address _minter,\n    address _msig,\n    address _xShadow,\n    address _clFactory,\n    address _clGaugeFactory,\n    address _nfpManager,\n    address _feeRecipientFactory,\n    address _voteModule,\n    address _launcherPlugin\n  ) external;\n\n  /// @notice denominator basis\n  function BASIS() external view returns (uint256);\n\n  /// @notice ratio of xShadow emissions globally\n  function xRatio() external view returns (uint256);\n\n  /// @notice xShadow contract address\n  function xShadow() external view returns (address);\n\n  /// @notice legacy factory address (uni-v2/stableswap)\n  function legacyFactory() external view returns (address);\n\n  /// @notice concentrated liquidity factory\n  function clFactory() external view returns (address);\n\n  /// @notice gauge factory for CL\n  function clGaugeFactory() external view returns (address);\n\n  /// @notice legacy fee recipient factory\n  function feeRecipientFactory() external view returns (address);\n\n  /// @notice peripheral NFPManager contract\n  function nfpManager() external view returns (address);\n\n  /// @notice returns the address of the current governor\n  /// @return _governor address of the governor\n  function governor() external view returns (address _governor);\n\n  /// @notice the address of the vote module\n  /// @return _voteModule the vote module contract address\n  function voteModule() external view returns (address _voteModule);\n\n  /// @notice address of the central access Hub\n  function accessHub() external view returns (address);\n\n  /// @notice the address of the shadow launcher plugin to enable third party launchers\n  /// @return _launcherPlugin the address of the plugin\n  function launcherPlugin() external view returns (address _launcherPlugin);\n\n  /// @notice distributes emissions from the minter to the voter\n  /// @param amount the amount of tokens to notify\n  function notifyRewardAmount(uint256 amount) external;\n\n  /// @notice distributes the emissions for a specific gauge\n  /// @param _gauge the gauge address\n  function distribute(address _gauge) external;\n\n  /// @notice returns the address of the gauge factory\n  /// @param _gaugeFactory gauge factory address\n  function gaugeFactory() external view returns (address _gaugeFactory);\n\n  /// @notice returns the address of the feeDistributor factory\n  /// @return _feeDistributorFactory feeDist factory address\n  function feeDistributorFactory() external view returns (address _feeDistributorFactory);\n\n  /// @notice returns the address of the minter contract\n  /// @return _minter address of the minter\n  function minter() external view returns (address _minter);\n\n  /// @notice check if the gauge is active for governance use\n  /// @param _gauge address of the gauge\n  /// @return _trueOrFalse if the gauge is alive\n  function isAlive(address _gauge) external view returns (bool _trueOrFalse);\n\n  /// @notice allows the token to be paired with other whitelisted assets to participate in governance\n  /// @param _token the address of the token\n  function whitelist(address _token) external;\n\n  /// @notice effectively disqualifies a token from governance\n  /// @param _token the address of the token\n  function revokeWhitelist(address _token) external;\n\n  /// @notice returns if the address is a gauge\n  /// @param gauge address of the gauge\n  /// @return _trueOrFalse boolean if the address is a gauge\n  function isGauge(address gauge) external view returns (bool _trueOrFalse);\n\n  /// @notice disable a gauge from governance\n  /// @param _gauge address of the gauge\n  function killGauge(address _gauge) external;\n\n  /// @notice re-activate a dead gauge\n  /// @param _gauge address of the gauge\n  function reviveGauge(address _gauge) external;\n\n  /// @notice re-cast a tokenID's votes\n  /// @param owner address of the owner\n  function poke(address owner) external;\n\n  /// @notice sets the main tickspacing of a token pairing\n  /// @param tokenA address of tokenA\n  /// @param tokenB address of tokenB\n  /// @param tickSpacing the main tickspacing to set to\n  function setMainTickSpacing(address tokenA, address tokenB, int24 tickSpacing) external;\n\n  /// @notice returns if the address is a fee distributor\n  /// @param _feeDistributor address of the feeDist\n  /// @return _trueOrFalse if the address is a fee distributor\n  function isFeeDistributor(address _feeDistributor) external view returns (bool _trueOrFalse);\n\n  /// @notice returns the address of the emission's token\n  /// @return _shadow emissions token contract address\n  function shadow() external view returns (address _shadow);\n\n  /// @notice returns the address of the pool's gauge, if any\n  /// @param _pool pool address\n  /// @return _gauge gauge address\n  function gaugeForPool(address _pool) external view returns (address _gauge);\n\n  /// @notice returns the address of the pool's feeDistributor, if any\n  /// @param _gauge address of the gauge\n  /// @return _feeDistributor address of the pool's feedist\n  function feeDistributorForGauge(address _gauge) external view returns (address _feeDistributor);\n\n  /// @notice returns the new toPool that was redirected fromPool\n  /// @param fromPool address of the original pool\n  /// @return toPool the address of the redirected pool\n  function poolRedirect(address fromPool) external view returns (address toPool);\n\n  /// @notice returns the gauge address of a CL pool\n  /// @param tokenA address of token A in the pair\n  /// @param tokenB address of token B in the pair\n  /// @param tickSpacing tickspacing of the pool\n  /// @return gauge address of the gauge\n  function gaugeForClPool(\n    address tokenA,\n    address tokenB,\n    int24 tickSpacing\n  ) external view returns (address gauge);\n\n  /// @notice returns the array of all tickspacings for the tokenA/tokenB combination\n  /// @param tokenA address of token A in the pair\n  /// @param tokenB address of token B in the pair\n  /// @return _ts array of all the tickspacings\n  function tickSpacingsForPair(\n    address tokenA,\n    address tokenB\n  ) external view returns (int24[] memory _ts);\n\n  /// @notice returns the main tickspacing used in the gauge/governance process\n  /// @param tokenA address of token A in the pair\n  /// @param tokenB address of token B in the pair\n  /// @return _ts the main tickspacing\n  function mainTickSpacingForPair(address tokenA, address tokenB) external view returns (int24 _ts);\n\n  /// @notice returns the block.timestamp divided by 1 week in seconds\n  /// @return period the period used for gauges\n  function getPeriod() external view returns (uint256 period);\n\n  /// @notice cast a vote to direct emissions to gauges and earn incentives\n  /// @param owner address of the owner\n  /// @param _pools the list of pools to vote on\n  /// @param _weights an arbitrary weight per pool which will be normalized to 100% regardless of numerical inputs\n  function vote(address owner, address[] calldata _pools, uint256[] calldata _weights) external;\n\n  /// @notice reset the vote of an address\n  /// @param owner address of the owner\n  function reset(address owner) external;\n\n  /// @notice set the governor address\n  /// @param _governor the new governor address\n  function setGovernor(address _governor) external;\n\n  /// @notice recover stuck emissions\n  /// @param _gauge the gauge address\n  /// @param _period the period\n  function stuckEmissionsRecovery(address _gauge, uint256 _period) external;\n\n  /// @notice whitelists extra rewards for a gauge\n  /// @param _gauge the gauge to whitelist rewards to\n  /// @param _reward the reward to whitelist\n  function whitelistGaugeRewards(address _gauge, address _reward) external;\n\n  /// @notice removes a reward from the gauge whitelist\n  /// @param _gauge the gauge to remove the whitelist from\n  /// @param _reward the reward to remove from the whitelist\n  function removeGaugeRewardWhitelist(address _gauge, address _reward) external;\n\n  /// @notice creates a legacy gauge for the pool\n  /// @param _pool pool's address\n  /// @return _gauge address of the new gauge\n  function createGauge(address _pool) external returns (address _gauge);\n\n  /// @notice create a concentrated liquidity gauge\n  /// @param tokenA the address of tokenA\n  /// @param tokenB the address of tokenB\n  /// @param tickSpacing the tickspacing of the pool\n  /// @return _clGauge address of the new gauge\n  function createCLGauge(\n    address tokenA,\n    address tokenB,\n    int24 tickSpacing\n  ) external returns (address _clGauge);\n\n  /// @notice claim concentrated liquidity gauge rewards for specific NFP token ids\n  /// @param _gauges array of gauges\n  /// @param _tokens two dimensional array for the tokens to claim\n  /// @param _nfpTokenIds two dimensional array for the NFPs\n  function claimClGaugeRewards(\n    address[] calldata _gauges,\n    address[][] calldata _tokens,\n    uint256[][] calldata _nfpTokenIds\n  ) external;\n\n  /// @notice claim arbitrary rewards from specific feeDists\n  /// @param owner address of the owner\n  /// @param _feeDistributors address of the feeDists\n  /// @param _tokens two dimensional array for the tokens to claim\n  function claimIncentives(\n    address owner,\n    address[] calldata _feeDistributors,\n    address[][] calldata _tokens\n  ) external;\n\n  /// @notice claim arbitrary rewards from specific gauges\n  /// @param _gauges address of the gauges\n  /// @param _tokens two dimensional array for the tokens to claim\n  function claimRewards(address[] calldata _gauges, address[][] calldata _tokens) external;\n\n  /// @notice claim arbitrary rewards from specific legacy gauges, and exit to shadow\n  /// @param _gauges address of the gauges\n  /// @param _tokens two dimensional array for the tokens to claim\n  function claimLegacyRewardsAndExit(\n    address[] calldata _gauges,\n    address[][] calldata _tokens\n  ) external;\n\n  /// @notice distribute emissions to a gauge for a specific period\n  /// @param _gauge address of the gauge\n  /// @param _period value of the period\n  function distributeForPeriod(address _gauge, uint256 _period) external;\n\n  /// @notice attempt distribution of emissions to all gauges\n  function distributeAll() external;\n\n  /// @notice distribute emissions to gauges by index\n  /// @param startIndex start of the loop\n  /// @param endIndex end of the loop\n  function batchDistributeByIndex(uint256 startIndex, uint256 endIndex) external;\n\n  /// @notice returns the votes cast for a tokenID\n  /// @param owner address of the owner\n  /// @return votes an array of votes casted\n  /// @return weights an array of the weights casted per pool\n  function getVotes(\n    address owner,\n    uint256 period\n  ) external view returns (address[] memory votes, uint256[] memory weights);\n\n  /// @notice returns an array of all the gauges\n  /// @return _gauges the array of gauges\n  function getAllGauges() external view returns (address[] memory _gauges);\n\n  /// @notice returns an array of all the feeDists\n  /// @return _feeDistributors the array of feeDists\n  function getAllFeeDistributors() external view returns (address[] memory _feeDistributors);\n\n  /// @notice sets the xShadowRatio default\n  function setGlobalRatio(uint256 _xRatio) external;\n\n  /// @notice whether the token is whitelisted in governance\n  function isWhitelisted(address _token) external view returns (bool _tf);\n\n  /// @notice function for removing malicious or stuffed tokens\n  function removeFeeDistributorReward(address _feeDist, address _token) external;\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}