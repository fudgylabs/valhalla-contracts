{"language":"Solidity","sources":{"src/utils/Multicall.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// halfarse gas inefficent multicall, cause the multicall3 is garbo\ncontract Multicall {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  struct Call2 {\n    address target;\n    bool success;\n    bool isStatic;\n    uint256 value;\n    bytes callData;\n  }\n\n  struct Call3 {\n    address target;\n    uint256 value;\n    bytes callData;\n  }\n\n  struct Result {\n    bool success;\n    bytes returnData;\n  }\n\n  // need to implement nested view functions\n  function multicallView(Call[] calldata calls) public view returns (Result[] memory) {\n    Result[] memory results = new Result[](calls.length);\n    for (uint256 i; i < calls.length; i++) {\n      (results[i].success, results[i].returnData) = calls[i].target.staticcall(calls[i].callData);\n    }\n\n    return results;\n  }\n\n  function multicallExecute(Call2[] calldata calls) public payable returns (Result[] memory) {\n    uint256 value = msg.value;\n    Result[] memory results = new Result[](calls.length);\n    for (uint256 i; i < calls.length; i++) {\n      if (calls[i].isStatic)\n        (results[i].success, results[i].returnData) = calls[i].target.staticcall(calls[i].callData);\n      else {\n        require(value >= calls[i].value);\n        value -= calls[i].value;\n        (results[i].success, results[i].returnData) = calls[i].target.call{ value: calls[i].value }(\n          calls[i].callData\n        );\n      }\n      if (calls[i].success) require(results[i].success == true);\n    }\n\n    (bool success, ) = payable(msg.sender).call{ value: address(this).balance }(\"\");\n    require(success);\n\n    return results;\n  }\n\n  function multicallExecuteAll(Call3[] calldata calls) public payable returns (Result[] memory) {\n    Result[] memory results = new Result[](calls.length);\n    for (uint256 i; i < calls.length; i++) {\n      (results[i].success, results[i].returnData) = calls[i].target.call{ value: calls[i].value }(\n        calls[i].callData\n      );\n    }\n\n    (bool success, ) = payable(msg.sender).call{ value: address(this).balance }(\"\");\n    require(success);\n\n    return results;\n  }\n\n  function getExtcodesize(address address_) public view returns (uint256 size_) {\n    assembly {\n      size_ := extcodesize(address_)\n    }\n  }\n\n  function at(address _addr) public view returns (bytes memory o_code) {\n    assembly {\n      let size := extcodesize(_addr)\n      o_code := mload(0x40)\n      mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n      mstore(o_code, size)\n      extcodecopy(_addr, add(o_code, 0x20), 0, size)\n    }\n  }\n\n  receive() external payable {}\n}\n"}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","@/=src/","src/=src/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}