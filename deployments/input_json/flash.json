{"language":"Solidity","sources":{"src/UniswapV3FlashSwap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\npragma abicoder v2;\n\naddress constant SWAP_ROUTER_02 = 0x9282a6C62932431B127753C1CD2ac4F6cC4CFD49; // wagmi\n\ncontract UniswapV3FlashSwap {\n    ISwapRouter02 constant router = ISwapRouter02(SWAP_ROUTER_02);\n\n    uint160 private constant MIN_SQRT_RATIO = 4295128739;\n    uint160 private constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n\n    // DAI / WETH 0.3% swap fee (2000 DAI / WETH)\n    // DAI / WETH 0.05% swap fee (2100 DAI / WETH)\n    // 1. Flash swap on pool0 (receive WETH)\n    // 2. Swap on pool1 (WETH -> DAI)\n    // 3. Send DAI to pool0\n    // profit = DAI received from pool1 - DAI repaid to pool0\n\n    function flashSwap(\n        address pool0,\n        uint24 fee1,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external {\n        bool zeroForOne = tokenIn < tokenOut;\n        // 0 -> 1 => sqrt price decrease\n        // 1 -> 0 => sqrt price increase\n        uint160 sqrtPriceLimitX96 =\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1;\n\n        bytes memory data = abi.encode(\n            msg.sender, pool0, fee1, tokenIn, tokenOut, amountIn, zeroForOne\n        );\n\n        IUniswapV3Pool(pool0).swap({\n            recipient: address(this),\n            zeroForOne: zeroForOne,\n            amountSpecified: int256(amountIn),\n            sqrtPriceLimitX96: sqrtPriceLimitX96,\n            data: data\n        });\n    }\n\n    function _swap(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) private returns (uint256 amountOut) {\n        IERC20(tokenIn).approve(address(router), amountIn);\n\n        ISwapRouter02.ExactInputSingleParams memory params = ISwapRouter02\n            .ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: address(this),\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMin,\n            sqrtPriceLimitX96: 0\n        });\n\n        amountOut = router.exactInputSingle(params);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata data\n    ) external {\n        // Decode data\n        (\n            address caller,\n            address pool0,\n            uint24 fee1,\n            address tokenIn,\n            address tokenOut,\n            uint256 amountIn,\n            bool zeroForOne\n        ) = abi.decode(\n            data, (address, address, uint24, address, address, uint256, bool)\n        );\n\n        uint256 amountOut = zeroForOne ? uint256(-amount1) : uint256(-amount0);\n\n        // pool0 -> tokenIn -> tokenOut (amountOut)\n        // Swap on pool 1 (swap tokenOut -> tokenIn)\n        uint256 buyBackAmount = _swap({\n            tokenIn: tokenOut,\n            tokenOut: tokenIn,\n            fee: fee1,\n            amountIn: amountOut,\n            amountOutMin: amountIn\n        });\n\n        // Repay pool 0\n        uint256 profit = buyBackAmount - amountIn;\n        require(profit > 0, \"profit = 0\");\n\n        IERC20(tokenIn).transfer(pool0, amountIn);\n        IERC20(tokenIn).transfer(caller, profit);\n    }\n}\n\ninterface ISwapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n\ninterface IUniswapV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","@/=src/","src/=src/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}